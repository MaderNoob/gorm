mod from_query_result;
mod migration;
mod select_values;
mod selected_value_to_order_by;
mod table;
mod update_set;
mod util;

use proc_macro::TokenStream;
use util::generate_field_name_cons_list_type;

/// A macro which allows selecting custom values from a query.
///
/// The input to this macro should be a list of comma seperated expression to
/// select from the query.
///
/// If one of the selected expressions is not just a column of some table, its
/// field name must be explicitly specified by adding `as <field_name>` at the
/// end of the expression. Note that sometimes you will need to add parentheses
/// around the expression in order for the `as <field_name>` to be detected by
/// this macro.
///
/// # Example
///
/// ```rust
/// #[derive(Table)]
/// struct Person {
///     id: i32,
///     age: i32,
///     name: String,
/// }
///
/// #[derive(FromQueryResult)]
/// struct NameAndIdPlusAge {
///     name: String,
///     id_plus_age: i32,
/// }
///
/// let _ = person::table
///     .find()
///     .select(select_values!(person::name, person::id.add(person::age) as id_plus_age))
///     .load_all::<NameAndIdPlusAge>(...)
///     .await?;
/// ```
///
/// # When To Use
///
/// Please note that if you only need to select one column, you dont need to use
/// this macro, for example:
///
/// ```rust
/// let names = person::table
///     .find()
///     .select(person::name)
///     .load_all_values(...)
///     .await?;
/// ```
///
/// Additionally, if you want to select all fields of some table, you can just
/// use the struct named `all` generated by the `Table` derive macro, for
/// example:
///
/// ```rust
/// let people = person::table
///     .find()
///     .select(person::all)
///     .load_all::<Person>(...)
///     .await?;
/// ```
///
/// Note that in the above example the `select` call has no effect on the query,
/// but in some cases it might be more useful to use the `all` struct, for
/// example when performing inner joins.
#[proc_macro]
pub fn select_values(input_tokens: TokenStream) -> TokenStream {
    select_values::select_values(input_tokens)
}

/// This macro is just another name for the [`select_values!`] macro, for usage
/// information check out the documentation on that macro.
#[proc_macro]
pub fn returning(input_tokens: TokenStream) -> TokenStream {
    select_values::select_values(input_tokens)
}

/// Implements the `Migration` trait for some struct, given the tables that it
/// should manage.
///
/// # Example
///
/// ```rust
/// struct MyMigration;
/// migration! { MyMigration =>  school, person}
///
/// // This is how you can use the migration. The up function creates all the tables in the correct
/// // order, and the down functions drops them.
/// MyMigration::up(...).await?;
/// MyMigration::down(...).await?;
///
/// #[derive(Table)]
/// struct Person {
///     id: i32,
///     name: String,
///     
///     #[table(foreign_key(School))]
///     school_id: i32,
/// }
///
/// #[derive(Table)]
/// struct School {
///     id: i32,
///     name: String,
/// }
/// ```
///
/// Please note that the order of tables that are provided to this macro must be
/// in the correct order by which the tables should be created. For example in
/// the example above if we were to put the `person` table before the `school`
/// table we would get an error because `person` has a foreign key to `school`.
#[proc_macro]
pub fn migration(input_tokens: TokenStream) -> TokenStream {
    migration::migration(input_tokens)
}

/// Implements the `FromQueryResult` trait for some struct.
///
/// This allows the struct to be loaded from query results, for example from
/// `SELECT` statements.
///
/// # Example
/// ```rust
/// #[derive(FromQueryResult)]
/// struct PersonNameAndSchoolName {
///     person_name: String,
///     school_name: String,
/// }
///
/// let _ = person::table.inner_join(school::table)
///     .find()
///     .select(select_values!(person::name as person_name, school::name as school_name))
///     .load_all::<PersonNameAndSchoolName>(...)
///     .await?;
///
/// #[derive(Table)]
/// struct Person {
///     id: i32,
///     name: String,
///     
///     #[table(foreign_key(School))]
///     school_id: i32,
/// }
///
/// #[derive(Table)]
/// struct School {
///     id: i32,
///     name: String,
/// }
/// ```
#[proc_macro_derive(FromQueryResult)]
pub fn from_query_result(input_tokens: TokenStream) -> TokenStream {
    from_query_result::from_query_result(input_tokens)
}

/// Given a field name as an ident, returns a field name typed cons list type.
#[proc_macro]
pub fn create_field_name_cons_list(item: TokenStream) -> TokenStream {
    generate_field_name_cons_list_type(&item.to_string()).into()
}

/// Implements the `Table` trait for the some struct, and creates a table module
/// for it containing some useful items which allow performing operations on
/// this table.
///
/// # Example
/// ```rust
/// #[derive(Table)]
/// #[table(unique(first_name, last_name))]
/// struct Person {
///     id: i32,
///     first_name: String,
///     last_name: String,
///     age: i32,
///
///     #[table(foreign_key(School))]
///     school_id: i32,
/// }
///
/// #[derive(Table)]
/// struct School {
///     id: i32,
///     name: String,
/// }
/// ```
///
/// The `Table` macro, besides implementing the `Table` trait for the provided
/// struct, will also create a module which has the same name as the struct, but
/// converted to `snake_case`. This module will contain useful items which allow
/// peforing operations on the table.
///
/// For example, for the `Person` struct, a module named `person` will be
/// created, containing the following items:
///
///  - A struct called `new` (`person::new`), which contains all fields of a
///    person other than its
///  id. The `new` struct implements the `Insertable` trait which allows
/// inserting it to the  database. The fields of this struct use the
/// [`std::borrow::Borrow`] trait to allow for  providing things that the actual
/// type can be borrowed us. For example when creating a school
///  using `school::new`, we can provide a value of type `&str` for the `name`
/// field.  
///  - A struct called `new_with_id`, same as the `new` struct but allows
///    specifying a value for
///  the id field.
///
///  - An empty struct called `table` (`person::table`), which implements the
///    `TableMarker` trait. This
///  struct allows you to perform operations on the table like `create`, `drop`,
/// `delete`, `find`,  `inner_join`.
///
///  - An empty struct called `all` (`person::all`) which implements the
///    `SelectedValues` trait and
///  allows selecting all fields of this table in functions which require
/// selecting custom values.
///
///  - An empty struct for each column in the table. For example in the above
///    example, the created structs
///  will be `person::id`, `person::first_name`, `person::last_name`,
/// `person::age` and  `person::school_id`. Each of these structs implement the
/// `SqlExpression` trait.
///
///  - A module named `unique_constraints` containing marker structs for each
///    unique constraint on the table. For example in the above example, the
///    created structs will be `person::unique_constraints::id` and
///    `person::unique_constraints::first_name_last_name`.
///
/// # Foreign Keys
///
/// Foreign keys can be implemented as shown in the example above using the
/// `#[table(foreign_key(...))]` attribute, and specifying the table struct's
/// name.
///
/// Foreign keys allow you to perform joins on the tables, and we can then
/// perform select queries on the joined tables, for example, for the above
/// snippet we can do the following:
///
/// ```rust
/// let _ = person::table.inner_join(school::table)
///     .find()
///     .filter(school::name.equals("Stanford"))
///     .load::<Person>(...)
///     .await?;
/// ```
///
/// Foreign keys can also be optional, for example:
/// ```rust
/// #[derive(Table)]
/// pub struct MaybeStudent {
///     id: i32,
///
///     #[table(foreign_key(School))]
///     school_id: Option<i32>,
/// }
/// ```
///
/// The inner join of the table `MaybeStudent` with the table `School` will then
/// only return the students who's `school_id` is not `None`.
///
/// Please note that the type of the foreign key field must match the type of
/// the referenced table's `id` field.
///
/// # Unique Constraints
///
/// Unique constraints can be implemented as shown in the example above using
/// the `#[table(unique(...))]` attribute, and specifying the fields on which
/// the unique constraint should enforce uniqueness.
/// 
/// If you want to add a unique constraint on a single field, you can also add a `#[table(unique)]`
/// attribute on one of the table struct's fields, for example:
/// ```rust
/// #[derive(Table)]
/// pub struct Person {
///     #[table(unique)]
///     full_name: String,
/// }
/// ```
///
/// You can create multiple unique constraints on a single table by adding
/// multiple `#[table(unique(...))]` attributes to the table struct.
///
/// A unique constraint for the id field is automatically created.
///
/// Unique constraints allow you to use `ON CONFLICT` clauses, and to perform
/// upserts, for example, for the above snippet, we can do the following:
///
/// ```rust
/// let upserted_person = person::new {
///     first_name: "James",
///     last_name: "Brown",
///     age: &44,
///     school_id: &2,
/// }
/// .insert()
/// .on_conflict(person::unique_constraints::first_name_last_name)
/// .do_update(update_set!(person::school_id = 2))
/// .returning(person::all)
/// .load_one::<Person>(...)
/// .await?;
/// ```
#[proc_macro_derive(Table, attributes(table))]
pub fn table(input_tokens: TokenStream) -> TokenStream {
    table::table(input_tokens)
}

/// This macro provides a way to order the results of a query by a value
/// selected using the `select_values` macro.
///
/// # Example
/// ```rust
/// let _ = person::table
///     .find()
///     .select(select_values!(
///         person::age.multiply(person::id) as some_name
///     ))
///     .order_by_selected_value_descending(selected_value_to_order_by!(some_name))
///     .load_all_values(...)
///     .await?;
///
/// #[derive(Table)]
/// struct Person {
///     id: i32,
///     name: String,
/// }
/// ```
#[proc_macro]
pub fn selected_value_to_order_by(input_tokens: TokenStream) -> TokenStream {
    selected_value_to_order_by::selected_value_to_order_by(input_tokens)
}

/// This macro allows providing a set of updates to perform on each row in an
/// sql update statement.
///
/// The input to this macro should be a comma seperated list of assignments of
/// sql expressions to columns, for example:
///
/// # Example
/// ```rust
/// let new_ages = person::table
///     .update()
///     .set(update_set!(person::age = person::age.add(1)))
///     .returning(person::age)
///     .load_all_values(...)
///     .await?;
///
/// #[derive(Table)]
/// struct Person {
///     id: i32,
///     age: i32,
/// }
/// ```
#[proc_macro]
pub fn update_set(input_tokens: TokenStream) -> TokenStream {
    update_set::update_set(input_tokens)
}
